
## don't ask "how much will this cost?", do say "do this with this much fuel" ##

- Any function's <body> can be wrapped in:
	- "if (fuel > __) { <body> } else { fuel -= c0; raise FuelException; }"  
	- it's minimum cost is some global constant c0. A simple stamp can be used to mark functions with min cost c0.
- Maybe 
	- stamp only functions that:
		- have a minimum cost of c0
		- decrease their fuel box by the correct amount
		- if it returns successfully, won't have decreased the fuel to below c0
			- if a fuel-check fails, fuel might be < c0, but >= 0
	- this way the cost associated with a function is true, and better integrates with other stamps/verifiers/provers etc.
	- these functions assume they have at least c0 fuel when called, and guarantee they leave at least c0 fuel when they return successfully, so they can be chained together temporally.



## w/o a fuel stack ##

- M: f:fn? -> (x:box<int?> -> f':fn?)
- M takes a function f and returns a function f' that:
	- takes a boxed int x
	- returns a function f' like the ones described above
- M needs access to fs source, which it makes a variant of and recompiles to make f'
	- M is like a dynamic macro, or some language level abstraction



## Types of behavior with limited fuel: ##

- Run only if have enough fuel
- Run block as many full times as possible
- Run as much as possible, then return continuation








